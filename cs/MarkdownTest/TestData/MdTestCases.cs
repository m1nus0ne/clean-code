namespace MarkdownTest.TestData;

public class MdTestData
{
    public static TestCaseData[] SpecExamples =
    {
        new TestCaseData(
            "Текст, _окруженный с двух сторон_ одинарными символами подчерка,\nдолжен помещаться в HTML-тег <em>.",
            "Текст, <em>окруженный с двух сторон</em> одинарными символами подчерка,\nдолжен помещаться в HTML-тег <em>."
        ).SetName("SimpleEmTagging"),
        new TestCaseData(
            "__Выделенный двумя символами текст__ должен становиться полужирным с помощью тега <strong>.",
            "<strong>Выделенный двумя символами текст</strong> должен становиться полужирным с помощью тега <strong>."
        ).SetName("SimpleStrongTagging"),
        new TestCaseData(
            "Любой символ можно экранировать, чтобы он не считался частью разметки.\n \\_Вот это\\_, не должно выделиться тегом <em>.",
            "Любой символ можно экранировать, чтобы он не считался частью разметки.\n _Вот это_, не должно выделиться тегом <em>."
        ).SetName("TagShielding"),
        new TestCaseData(
            "Символ экранирования исчезает из результата, только если экранирует что-то.\nЗдесь сим\\волы экранирования\\ \\должны остаться.\\",
            "Символ экранирования исчезает из результата, только если экранирует что-то.\nЗдесь сим\\волы экранирования\\ \\должны остаться.\\"
        ).SetName("ReverseSlashes_RemainItselfIfDoesNotShielding"),
        new TestCaseData(
            @"Символ экранирования тоже можно экранировать: \\_вот_ это будет выделено тегом <em>",
            @"Символ экранирования тоже можно экранировать: \<em>вот</em> это будет выделено тегом <em>"
        ).SetName("ShieldingReverseSlash"),
        new TestCaseData(
            "Внутри __двойного выделения _одинарное_ тоже__ работает.",
            "Внутри <strong>двойного выделения <em>одинарное</em> тоже</strong> работает."
        ).SetName("EmInStrongWork"),
        new TestCaseData(
            "Но не наоборот — внутри _одинарного __двойное__ не_ работает.",
            "Но не наоборот — внутри <em>одинарного __двойное__ не</em> работает."
        ).SetName("StrongInEmDoesNotWork"),
        new TestCaseData(
            "Подчерки внутри текста c цифрами_12_3 не считаются выделением и должны оставаться символами подчерка.",
            "Подчерки внутри текста c цифрами_12_3 не считаются выделением и должны оставаться символами подчерка."
        ).SetName("TaggingNumber_RemainUnderscores"),
        new TestCaseData(
            "Однако выделять часть слова они могут: и в _нач_але, и в сер_еди_не, и в кон_це._",
            "Однако выделять часть слова они могут: и в <em>нач</em>але, и в сер<em>еди</em>не, и в кон<em>це.</em>"
        ).SetName("TaggingInDifferentPartsOfWord"),
        new TestCaseData(
            "В то же время выделение в ра_зных сл_овах не работает.",
            "В то же время выделение в ра_зных сл_овах не работает."
        ).SetName("TaggingInDifferentWordsDoesNotWork"),
        new TestCaseData(
            "__Непарные_ символы в рамках одного абзаца не считаются выделением.",
            "__Непарные_ символы в рамках одного абзаца не считаются выделением."
        ).SetName("NotPairedSymbols_RemainIteself"),
        new TestCaseData(
            "За подчерками, начинающими выделение, должен следовать непробельный символ. Иначе эти_ подчерки_ не считаются выделением \nи остаются просто символами подчерка.",
            "За подчерками, начинающими выделение, должен следовать непробельный символ. Иначе эти_ подчерки_ не считаются выделением \nи остаются просто символами подчерка."
        ).SetName("SingleUnderscoreWithWhitespaceAhead_RemainUnderscore"),
        new TestCaseData(
            "Подчерки, заканчивающие выделение, должны следовать за непробельным символом. Иначе эти _подчерки _не считаются_ окончанием выделения \nи остаются просто символами подчерка.",
            "Подчерки, заканчивающие выделение, должны следовать за непробельным символом. Иначе эти <em>подчерки _не считаются</em> окончанием выделения \nи остаются просто символами подчерка."
        ).SetName("SingleInderscore_RemainUnderscoreInEmTag"),
        new TestCaseData(
            "В случае __пересечения _двойных__ и одинарных_ подчерков ни один из них не считается выделением.",
            "В случае __пересечения _двойных__ и одинарных_ подчерков ни один из них не считается выделением."
        ).SetName("TagsIntersection_RemainUnderscores"),
        new TestCaseData(
            "Если внутри подчерков пустая строка ____, то они остаются символами подчерка.",
            "Если внутри подчерков пустая строка ____, то они остаются символами подчерка."
        ).SetName("TwoDoubleUnderscoresInRow_RemainUnderscores"),
        new TestCaseData(
            "# Заголовок __с _разными_ символами__",
            "<h1>Заголовок <strong>с <em>разными</em> символами</strong></h1>"
        ).SetName("HeaderWithInnerTags"),
        new TestCaseData(
            "- First item\n" +
            "- Second item\n" +
            "- Third item\n",
            "<li>First item</li>\n<li>Second item</li>\n<li>Third item</li>\n"
        ).SetName("UnorderedList"),
    };

}